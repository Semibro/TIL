# TIL (_Today I Learn_)

<br>

## 2023. 12. 01 ~ 2023. 12. 07

```
프로젝트로 인한 생략
```

<br>

## 2023. 12. 08

```
TIL을 다시 시작합니다.

Heap에 대한 이해를 위해 알고리즘 문제 풀이
```
[Heap 바로가기](https://github.com/Semibro/DataStructure_Algorithm/blob/main/Data_Structure/Heap.md)

<br>

## 2023. 12. 09

```
토요일 휴무
```

<br>

## 2023. 12. 10

```
이항계수에 대한 공부를 진행

모듈러 연산 및 모듈러 연산의 역원 그리고 페르마의 소정리

피보나치 수열을 푸는 문제 중, 피사노 주기에 대해서 공부를 진행
```
[이항 계수 알고리즘 바로가기](https://github.com/Semibro/DataStructure_Algorithm/blob/main/Algorithm/Binomial-Coefficient.md) <br/>
[피사노 주기 알고리즘 바로가기](https://github.com/Semibro/DataStructure_Algorithm/blob/main/Algorithm/Fibonacci_PisanoPeriod.md)

<br/>

## 2023. 12. 11

```
트리의 지름에 대해서 공부를 진행

트리의 지름을 구하는 알고리즘
-> 트리에서 임의의 노드(보통은 루트 노드)를 선택한 뒤, 해당 노드에서 가장 먼 노드를 시작지점으로 선택.
-> 그 후, 해당 노드에서 가장 먼 노드를 구하면 해당 길이가 트리의 노드가 된다.
```
[트리의 지름 알고리즘 바로가기](https://github.com/Semibro/DataStructure_Algorithm/blob/main/Algorithm/Tree-Diameter.md)

<br/>

## 2023. 12. 12

```
포트폴리오 작성으로 인한 휴무

*트리의 지름 문제 1solved*
```

<br/>

## 2023. 12. 13

```
기업 입사 지원서 작성으로 인한 생략
```

<br/>

## 2023. 12. 14 ~ 2023. 12. 19

```
면접 준비로 인한 생략
```

<br/>

## 2023. 12. 20

[ Apache Kafka ]

1. 메시징 시스템
  - Publisher와 Subscriber로 이루어진 비동기 메시징 전송 방식
  - 메시지라고 불리는 데이터 단위를 보내는 측(Publisher/Producer)에서 메시지 시스템에 메시지를 저장하면 가져가는 측(Subscriber/Consumer)는 데이터를 수신
  - 발신자의 메시지에는 수신자가 정해져 있지 않은 상태로 발행(Publish)
  - 구독(Subscribe)을 신청한 수신자만이 정해진 메시지를 받음
  - 수신자는 발신자 정보가 없얻 메시지 수신이 가능
  - 일반적인 형태의 네트워크 통신의 경우 N:N연결이므로 클라이언트가 갑자기 많아질 경우 느려질 수 있고, 이를 대응하기 위한 확정성이 떨어짐
  - 특정 클라이언트가 다운돼서 메시지를 받지 못하게 될 경우 메시지가 유실될 수 있음

Kafka의 방식
  - 작동방식
    - 프로듀서가 메시지를 컨슈머에게 직접 전달하는 것이 아니라 중간의 메시징 시스템에 전달
    - 메시징 시스템의 교환기가 메시지의 수신처 ID값을 통해 컨슈머들의 큐에 메시지를 전달
    - 컨슈머는 큐를 모니터링하다가 큐에 메시지가 있을 경우 값을 회수
  - 장점
    - 특정 개체가 수신불능 상태가 되더라도 메시징 시스템만 살아있다면 메시지가 유실되지 않음
    - 메시징 시스템으로 연결되어 있기 때문에 확장성이 용이
  - 단점
    - 직접 통신하지 않기 때문에 메시지가 잘 전달되었는지 파악이 힘듦
    - 중간에 메시징 시스템을 거치기 때문에 메시지 전달 속도가 빠르지 않음

2. 카프카는 무엇인가

  - 아키텍처
    - 프로듀서
      - 메시지를 생산하여 브로커의 토픽으로 전달하는 역할
    - 브로커
      - 카프카 애플리케이션이 설치되어 있는 서버 또는 노드를 지칭
    - 컨슈머
      - 브로커의 토픽으로부터 저장된 메시지를 전달받는 역할
    - 주키퍼
      - 분산 애플리케이션 관리를 위한 코디네이션 시스템
      - 분산된 노드의 정보를 중앙에 집중하고 구성관리, 그룹 네이밍, 동기화 등의 서비스 수행
  - 작동방식
    - 프로듀서는 새 메시지를 카프카에 전달
    - 전달된 메시지는 브로커의 토픽이라는 메시지 구분자에 저장
    - 컨슈머는 구독한 토픽에 접근하여 메시지를 가져옴
  - 기존 메시징 시스템과 다른 점
    - 디스크에 메시지 저장
      - 기존 메시징 시스템은 컨슈머가 메시지를 소비하면 큐에서 바로 메시지를 삭제
      - 하지만 카프카는 컨슈머가 메시지를 소비하더라도 디스크에 메시지를 일정기간 보관하기 때문에 메시지의 손실이 없음 (영속성)
    - 멀티 프로듀서, 멀티 컨슈머
      - 카프카의 경우 디스크에 메시지를 저장하는 특징으로 인해 프로듀서와 컨슈머 모두 하나 이상의 메시지를 주고 받음
    - 분산형 스트리밍 플랫폼
      - 단일 시스템 대비 성능이 우수하며 시스템 확장이 용이
      - 일부 노드가 죽더라도 다른 노드가 해당 일을 지속 (고가용성)
    - 페이지 캐시
      - 카프카는 잔여 메모리를 이용해 디스크 Read/Write를 하지 않고 페이지 캐시를 통한 Read/Write으로 인해 처리속도가 매우 빠름
    - 배치 전송 처리
      - 서버와 클라이언트 사이에서 비번하게 발생하는 메시지 통신을 하나씩  처리할 경우 그 만큼 네트워크 왕복의 오버헤드가 발생
      - 이로인해 메시지를 작은 단위로 묶어 배치 처리를 함으로써 속도 향상에 큰 도움을 줌

[참고문헌](https://velog.io/@jaehyeong/Apache-Kafka%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)


<br/>

## 2023. 12. 21 ~ 2023. 12. 31

```

생략

```